package main

import (
	"fmt"
	"log"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

func readInput(fname string) string {
	content, err := os.ReadFile(fname)
	if err != nil {
		log.Fatal(err)
	}

	// Convert []byte to string
	return string(content)
}

func main() {
	args := os.Args
	if len(args) < 2 {
		fmt.Printf("Enter input file name.\n")
		return
	}
	params := os.Args[1]
	inputName := strings.Split(params, " ")[0]
	text := readInput(inputName)
	start := time.Now()
	run(text)
	end := time.Now()
	fmt.Printf("Running time: %v\n", end.Sub(start))
	start = time.Now()
	run2(text)
	end = time.Now()
	fmt.Printf("Running time: %v\n", end.Sub(start))
}

func getSeeds(input string) []int {
	input = strings.TrimPrefix(input, "seeds: ")
	input = strings.TrimSpace(input)
	seedStrings := strings.Split(input, " ")
	seeds := make([]int, len(seedStrings))
	for i, seedString := range seedStrings {
		seed, _ := strconv.Atoi(seedString)
		seeds[i] = seed
	}
	return seeds
}

func getSeeds2(input string) []sourceRangeType {
	input = strings.TrimPrefix(input, "seeds: ")
	input = strings.TrimSpace(input)
	seedStrings := strings.Split(input, " ")
	seeds := make([]sourceRangeType, len(seedStrings)/2)
	for i := 0; i < len(seedStrings); i += 2 {
		startString := seedStrings[i]
		lengthString := seedStrings[i+1]
		start, _ := strconv.Atoi(startString)
		length, _ := strconv.Atoi(lengthString)
		seeds[i/2] = sourceRangeType{start, length}
	}
	return seeds
}

type rangeType struct {
	startKey   int
	startValue int
	length     int
}

type sourceRangeType struct {
	start  int
	length int
}

func getRange(line string) rangeType {
	line = strings.TrimSpace(line)
	rangeStrings := strings.Split(line, " ")
	startValue, _ := strconv.Atoi(rangeStrings[0])
	startKey, _ := strconv.Atoi(rangeStrings[1])
	length, _ := strconv.Atoi(rangeStrings[2])
	return rangeType{startKey, startValue, length}
}

func mapSourceToDest(rangeMaps []rangeType, source int) int {
	for _, rangeMap := range rangeMaps {
		if source >= rangeMap.startKey && source < rangeMap.startKey+rangeMap.length {
			return rangeMap.startValue + (source - rangeMap.startKey)
		}
	}
	return source
}

type mapNameType struct {
	key   string
	value string
}

func createMapFromSection(section string, rangeMap map[string][]rangeType, mapMap map[string]string) (map[string][]rangeType, map[string]string) {
	lines := strings.Split(section, "\n")
	mapNameString := strings.TrimSuffix(lines[0], " map:")
	mapNameStrings := strings.Split(mapNameString, "-to-")
	mapName := mapNameType{mapNameStrings[0], mapNameStrings[1]}
	lines = lines[1:]
	ranges := make([]rangeType, 0)
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		ranges = append(ranges, getRange(line))
	}
	// sort the ranges by key
	sort.Slice(ranges, func(i, j int) bool {
		return ranges[i].startKey < ranges[j].startKey
	})
	rangeMap[mapName.key] = ranges
	mapMap[mapName.key] = mapName.value
	return rangeMap, mapMap
}

func mapSeedToLocation(seed int, rangeMap map[string][]rangeType, mapMap map[string]string) int {
	sourceMapName := "seed"
	destMapName := mapMap[sourceMapName]
	source := seed
	var dest int
	for sourceMapName != "location" {
		dest = mapSourceToDest(rangeMap[sourceMapName], source)
		sourceMapName = destMapName
		destMapName = mapMap[sourceMapName]
		source = dest
	}

	return dest
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func mapSourceRangeToDestRanges(sourceRanges []sourceRangeType, rangeMaps []rangeType) []sourceRangeType {
	// the rangeMaps are sorted by startKey (probably not needed)
	// first split the source ranges into ranges that are completely contained in a single rangeMap
	for i := 0; i < len(sourceRanges); i++ {
		// find the first rangeMap that contains the start of the source range
		var rangeMap rangeType
		for _, rangeMap = range rangeMaps {
			if sourceRanges[i].start >= rangeMap.startKey &&
				sourceRanges[i].start < rangeMap.startKey+rangeMap.length {
				// found the first range that contains the start of the source range
				break
			}
		}
		// if the source range is longer than the range, split it into two ranges
		// now the source range is completely contained in the destination range
		// so we can just add it to the destination ranges
		if sourceRanges[i].start+sourceRanges[i].length > rangeMap.startKey+rangeMap.length {
			var newRange sourceRangeType
			newRange.start = rangeMap.startKey + rangeMap.length
			newRange.length = sourceRanges[i].start + sourceRanges[i].length - newRange.start
			sourceRanges = append(sourceRanges, newRange)
			sourceRanges[i].length = rangeMap.length - (sourceRanges[i].start - rangeMap.startKey)
		}
	}

	// now map all the source ranges to destination ranges
	destRanges := make([]sourceRangeType, 0)
	for _, sourceRange := range sourceRanges {
		// find the first rangeMap that contains the start of the source range
		var rangeMap rangeType
		var j int
		for j, rangeMap = range rangeMaps {
			if sourceRange.start >= rangeMap.startKey &&
				sourceRange.start < rangeMap.startKey+rangeMap.length {
				// found the first range that contains the start of the source range
				break
			}
		}
		var newRange sourceRangeType
		if j < len(rangeMaps) {
			// map the source range to the destination range
			newRange.start = rangeMap.startValue + (sourceRange.start - rangeMap.startKey)
			newRange.length = min(sourceRange.length, rangeMap.length)
		} else {
			// just copy the source range to the destination range
			newRange.start = sourceRange.start
			newRange.length = sourceRange.length
		}
		destRanges = append(destRanges, newRange)
	}
	return destRanges
}

func run(input string) string {
	sections := strings.Split(input, "\n\n")
	seeds := getSeeds(sections[0])
	fmt.Printf("Seeds: %v\n", seeds)
	rangeMap := make(map[string][]rangeType)
	mapMap := make(map[string]string)

	for _, section := range sections[1:] {
		rangeMap, mapMap = createMapFromSection(section, rangeMap, mapMap)
	}

	seedLocationMap := make(map[int]int)
	minLocation := math.MaxInt
	for _, seed := range seeds {
		seedLocationMap[seed] = mapSeedToLocation(seed, rangeMap, mapMap)
		if seedLocationMap[seed] < minLocation {
			minLocation = seedLocationMap[seed]
		}
	}

	fmt.Printf("Min location: %v\n", minLocation)
	return fmt.Sprintf("%v", minLocation)
}

func run2(input string) string {
	sections := strings.Split(input, "\n\n")

	// seed ranges are pairs of integers. The first is the offset, the second is the length
	seedRanges := getSeeds2(sections[0])
	fmt.Printf("Seeds: %v\n", seedRanges)
	rangeMap := make(map[string][]rangeType)
	mapMap := make(map[string]string)

	for _, section := range sections[1:] {
		rangeMap, mapMap = createMapFromSection(section, rangeMap, mapMap)
	}

	// seedLocationMap := make(map[int]int)
	sourceMap := "seed"
	destMap := mapMap[sourceMap]
	minLocation := math.MaxInt
	destRanges := make([]sourceRangeType, 0)
	sourceRanges := seedRanges
	sort.Slice(sourceRanges, func(i, j int) bool {
		return seedRanges[i].start < seedRanges[j].start
	})
	for sourceMap != "location" {
		destRanges = append(destRanges, mapSourceRangeToDestRanges(sourceRanges, rangeMap[sourceMap])...)
		sourceMap = destMap
		destMap = mapMap[sourceMap]
		sourceRanges = destRanges
		sort.Slice(sourceRanges, func(i, j int) bool {
			return destRanges[i].start < destRanges[j].start
		})
		destRanges = make([]sourceRangeType, 0)
	}

	fmt.Printf("Min location: %v\n", sourceRanges[0].start)
	return fmt.Sprintf("%v", minLocation)
}
